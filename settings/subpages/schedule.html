<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <script type="text/javascript">
      let module = {}; // Just to get around that some of the included files are used both by node.js and in the browser
      let wizExplainSchedule = [];

      function onWizLoaded() {
        wizExplainSchedule = [
          { action: UI_SHOW_OVERLAY },
          { action: UI_FORCE_NEXT, hint: 'Welcome to the schedule wizzard! <br>We will now go through the process of creating a schedule and configure it to your needs.<br>You can move this window around however you want and exit the wizzard at any time.'},
          { action: UI_FORCE_CLICK, id: 'newButton', hint: 'First click the "New" button to create a new schedule.' },
          { action: UI_FORCE_NEXT, id: 'timerOpName', hint: 'Select an appropriate name of the schedule and click next to continue.' },
          { action: UI_FORCE_CLICK, id: 'si0', hint: 'As you can see, your new schedule contains one timer lasting the whole day. Click to configure it.' },
          { action: UI_FORCE_NEXT, id: 'timerOpOnOff', require: 3, hint: 'For this timeslot we want the devices to stay on, but still turn off when needed in order to meet any limitations you may have configured.<br>For this to function, select the option Preferred On and click Next to continue.' },
          { action: UI_FORCE_NEXT, id: 'timerOpTemp', require: 1, hint: 'As a first step we want to start with a constant temperature. Select Constant temperature and click Next to continue.' },
          { action: UI_FORCE_NEXT, id: 'timerACMode', require: 2, hint: 'Select heating and press next to continue.' },
          { action: UI_FORCE_NEXT, id: 'myThermostat', require: [5,15], hint: 'Now you can select one temperature for heating and one temperature that emulates turning the device off. Select 15 degrees for on and 5 degrees for off and then click Next to continue.<br>You may click the thermostat center in order to make it bigger.' },
          { action: UI_FORCE_CLICK, id: 'addTimer', hint: 'Let\'s add another timeslot to the schedule so the temperature can be changed throughout the day. Click \'+\' to add another timeslot and click next to continue.'},
          { action: UI_FORCE_NEXT, id: 's0', require: '7:00', hint: 'Now drag the start of the new timeslot to 7:00 and click next to continue.' },
          { action: UI_FORCE_CLICK, id: 'si1', hint: 'Now select the new timeslot by clicking it.' },
          { action: UI_FORCE_NEXT, id: 'timerOpTemp', require: 2, hint: 'In this timeslot we want temperatures to be dependent on the electricity price. Select price controlled and click next to continue.' },
          //{ action: UI_FORCE_NEXT, id: 'myThermostat', require: [5,15,16,17,18,19], hint: 'Now you can select five temperatures for the different price points and one temperature that emulates turning the device off. Select 15 degrees for on and 5 degrees for off and then click Next to continue.<br>You may click the thermostat center in order to make it bigger.' },
          { action: UI_FORCE_NEXT, hint: 'This is as far as the wizzard goes. However, it\'s under development and will be expanded.' },
          { action: UI_HIDE_OVERLAY },
        ];
        setWizOverrides();
      };
    </script>
    <script type="text/javascript" src="../constants.js"></script>
    <script type="text/javascript" src="../tools.js"></script>
    <script type="text/javascript" src="./wizzard.js"></script>
    <link href="../style.css" rel="stylesheet" type="text/css">
    <link href="../trashcan.css" rel="stylesheet" type="text/css">
    <style>
.maxWidth {
  max-width: calc(100vh / 10 * 9);
  width: 100%;
  height: 100%;
  position: relative;
}

.centerText {
  text-align: center;
  color: black;
}

.closeButton {
    display: inline-block;
    position: relative;
    text-align:center;
    font-size: 1em;
    height: 19px;
    border: 1px solid black;
    border-radius: 4px;
    color: black;
    padding: 2px;
    min-width: 70px;
    background-color: lightgray;
    -webkit-user-select: none; /* Safari */
    -ms-user-select: none; /* IE 10 and IE 11 */
    user-select: none; /* Standard syntax */
  }

.closeButton:hover {
  box-shadow: 0px 0px 10px 2px gold;
}

.scheduleLegend {
  display: table;
  padding: 0px;
  border-spacing: 0px;
  border: solid 0px;
}

.scheduleLegendBox {
  width: 50px;
  vertical-align: top;
  padding: 0px;
  border: solid 0px;
  border-right: solid 1px;
}

.scheduleLegendText {
  height: 16px;
  font-weight: bold;
  font-family: monospace;
  font-size: 0.8rem;
  text-transform: uppercase;
  text-align: right;
  padding-top: 0px;
  position: relative;
  padding-right: 10px;
  overflow: hidden;
}

.scheduleLegendText:after{
  content:"   ";
  height: 2px;
  width: 5px;
  background: black;
  display: block;
  position: absolute;
  top: 50%;
  right: 0;
  overflow: hidden;
}

.schedulePlan {
  display: table-cell;
  width: 130px;
  vertical-align: top;
  padding: 0rem;
  border-right: solid 0px;
  touch-action: none;
}

.scheduleItem {
  display: block;
  overflow: auto;
  position: relative;
  border-radius: 8px;
  width: 100%;
  padding: 0px;
  padding-top: 5px;
  border: solid 0px;
  text-align:center;
  font-size: 0.7rem;
  box-sizing: border-box;
}

.schedCol0 {
  /* UNCONDITIONAL_OFF */
  border: solid gray 1px;
  background-image: linear-gradient(lightgray, gray);
}

.schedCol1 {
  /* UNCONDITIONAL_ON*/
  border: solid red 1px;
  background-image: linear-gradient(rgb(255, 255, 150), orange);
}

.schedCol2 {
  /* CONTROLLED_OFF */
  border: solid black 1px;
  background-image: linear-gradient(green, gray);
}

.schedCol3 {
  /* CONTROLLED_ON */
  border: solid green 1px;
  background-image: linear-gradient(green, rgb(150, 255, 150));
}

.schedCol4 {
  /* IGNORE */
  border: solid black 1px;
  background-image: repeating-linear-gradient(145deg, orange, orange 15%, gray 15%, gray 25%, orange 25%);
}

.schedCol5 {
  /* CONTROLLED_CHEAPEST */
  border: solid black 1px;
  background-image: repeating-linear-gradient(145deg, green, green 15%, gray 15%, gray 25%, green 25%);
}

.scheduleSelect {
  opacity: 0.6;
}

.scheduleSpacer {
  display: block;
  position: absolute;
  left: 20%;
  right: 20%;
  padding: 0px;
  border: 0px;
  height: 20px;
  background-image: linear-gradient(rgba(100,100,100,0), rgba(128,128,128,0.6) 35%, rgba(0,0,0,0.6) 35% 45%, rgba(128,128,128,0.6) 45% 55%, rgba(0,0,0,0.6) 55% 65%, rgba(128,128,128,0.6) 65%, rgba(100,100,100,0));
  z-index: 1;
}

.scheduleSpacer:hover {
  cursor: ns-resize;
}

.thermo {
  position: relative;
  border: 0px solid #d3d3d3;
  touch-action: none;
  width:100%;
}

.helpBg {
  font-size: 0.8em;
  color: gray;
  visibility:visible;
  display:none;
  position: fixed;
  width: 100%;
  height: 100%;
  top: 0%;
  left: 0%;
  right: 0%;
  bottom: 0%;
  background-color: rgba(0,0,0,0.7);
  z-index: 50;
  overflow: scroll;
  touch-action: pan-y;
}

.helpText{
  position: absolute;
  top: 10%;
  left: 10%;
  font-size: 20px;
  color: white;
  transform: translate(-5%,-10%);
  -ms-transform: translate(-5%,-10%);
  display: none;
}

.helpText p,
.helpText div {
  font-size: 0.6em;
  color: white;
}
    </style>
  </head>
  <body>
    <!-- Translation strings -->
    <div style="display:none" data-i18n="thermostat.HeatOff" id="HeatOffText"></div>
    <div style="display:none" data-i18n="thermostat.HeatExtreme" id="HeatExtremeText"></div>
    <div style="display:none" data-i18n="thermostat.HeatExpensive" id="HeatExpensiveText"></div>
    <div style="display:none" data-i18n="thermostat.HeatNormal" id="HeatNormalText"></div>
    <div style="display:none" data-i18n="thermostat.HeatCheap" id="HeatCheapText"></div>
    <div style="display:none" data-i18n="thermostat.HeatDirtCheap" id="HeatDirtCheapText"></div>
    <div style="display:none" data-i18n="thermostat.CoolDirtCheap" id="CoolDirtCheapText"></div>
    <div style="display:none" data-i18n="thermostat.CoolCheap" id="CoolCheapText"></div>
    <div style="display:none" data-i18n="thermostat.CoolNormal" id="CoolNormalText"></div>
    <div style="display:none" data-i18n="thermostat.CoolExpensive" id="CoolExpensiveText"></div>
    <div style="display:none" data-i18n="thermostat.CoolExtreme" id="CoolExtremeText"></div>
    <div style="display:none" data-i18n="thermostat.CoolOff" id="CoolOffText"></div>

    <!-- Help dialog -->
    <div id="helpPage" class="helpBg" onclick="helpOff()">
      <div id="onOffOperationHint" class="helpText">
        <h1 data-i18n="settings.schedule.onoff">schedule.onoff</h1>
        <p data-i18n="settings.schedule.hint.onOffOperation" class="helpText">hint.onOffOperation</p>
        <p><b data-i18n="settings.schedule.operations.alwaysOff"></b>: <i data-i18n="settings.schedule.opHelp.alwaysOff"></i></p>
        <p><b data-i18n="settings.schedule.operations.alwaysOn"></b>: <i data-i18n="settings.schedule.opHelp.alwaysOn"></i></p>
        <p><b data-i18n="settings.schedule.operations.controlledOn"></b>: <i data-i18n="settings.schedule.opHelp.controlledOn"></i></p>
        <p><b data-i18n="settings.schedule.operations.controlledOnCheapest"></b>: <i data-i18n="settings.schedule.opHelp.controlledOnCheapest"></i></p>
        <p><b data-i18n="settings.schedule.operations.controlledOff"></b>: <i data-i18n="settings.schedule.opHelp.controlledOff"></i></p>
        <p><b data-i18n="settings.schedule.operations.ignore"></b>: <i data-i18n="settings.schedule.opHelp.ignore"></i></p>
      </div>
      <div id="tempOpHint" class="helpText">
        <h1 data-i18n="settings.schedule.temp">schedule.temp</h1>
        <i data-i18n="settings.schedule.hint.tempOp">hint.tempOp</i>
      </div>
      <div id="ACModeHint" class="helpText">
        <h1 data-i18n="settings.ACMode.header">ACMode.header</h1>
        <i data-i18n="settings.schedule.hint.ACMode">hint.ACMode</i>
      </div>
      <div id="myThermoHint" class="helpText">
        <h1 data-i18n="settings.schedule.temp">schedule.temp</h1>
        <i data-i18n="settings.schedule.hint.myThermo">hint.myThermo</i>
      </div>
      <div id="previewHint" class="helpText">
        <h1>NOTE!</h1>
        <p>This is a preview / testing ground of upcoming functionality. The Layout may differ in the final version. Absolutely nothing will be affected if you play around here.</p>
        <p>The intent is that you can assign a schedule per device under each mode instead of an operation.</p>
        <p>Price behavior is likely to be part of the schedule.</p>
        <p>If you have any feedback before this is finalized please put it in the forum.</p>
      </div>
    </div>
    <script>
      let prevOn;
      function helpOn(elem) {
        document.getElementById("helpPage").style.display = 'block';
        console.log(`Help for ${elem}`)
        prevOn = document.getElementById(elem);
        prevOn.style.display = 'block';
      }
      function helpOff() {
        prevOn.style.display = 'none';
        document.getElementById("helpPage").style.display = 'none';
      }
    </script>
    <!-- End of Help dialog -->

    <h3>Time Schedule Preview</h3>
    <fieldset>
      <legend data-i18n="settings.schedule.schedules">Schedules</legend>

      <table>
        <tr>
          <td><select style="width: 150px" id="allSchedules" onchange="selectSchedule(this.value);"></select></td>
          <td><div class="closeButton" data-i18n="settings.schedule.remove" onclick="removeSchedule();">Remove</div></td>
          <td rowspan="2" valign="top"><img class="wizWand" src="wand.png" onclick="runActionQueue(wizExplainSchedule)"></td></tr>
        <tr>
          <td><input style="width: 150px; position: relative;" id="timerOpName" type="text" onchange="parent.schedules[scheduleSelected].name = this.value || 'Noname';refreshSchedules();displaySaveHint()"></td>
          <td><div id="newButton" class="closeButton" data-i18n="settings.schedule.new" onclick="addSchedule();">New</div></td></tr>
      </table>
    </fieldset>
    <table class="scheduleLegend">
      <tr style="height:400px">
        <td class="scheduleLegendBox"><div class="scheduleLegendText">0:00</div>
          <div class="scheduleLegendText">1:00</div>
          <div class="scheduleLegendText">2:00</div>
          <div class="scheduleLegendText">3:00</div>
          <div class="scheduleLegendText">4:00</div>
          <div class="scheduleLegendText">5:00</div>
          <div class="scheduleLegendText">6:00</div>
          <div class="scheduleLegendText">7:00</div>
          <div class="scheduleLegendText">8:00</div>
          <div class="scheduleLegendText">9:00</div>
          <div class="scheduleLegendText">10:00</div>
          <div class="scheduleLegendText">11:00</div>
          <div class="scheduleLegendText">12:00</div>
          <div class="scheduleLegendText">13:00</div>
          <div class="scheduleLegendText">14:00</div>
          <div class="scheduleLegendText">15:00</div>
          <div class="scheduleLegendText">16:00</div>
          <div class="scheduleLegendText">17:00</div>
          <div class="scheduleLegendText">18:00</div>
          <div class="scheduleLegendText">19:00</div>
          <div class="scheduleLegendText">20:00</div>
          <div class="scheduleLegendText">21:00</div>
          <div class="scheduleLegendText">22:00</div>
          <div class="scheduleLegendText">23:00</div>
          <div class="scheduleLegendText">24:00</div></td>
        <td width="10"></td>
        <td id="scheduleContainer" class="schedulePlan" onpointerup="dragStop(event)" onpointermove="moving(event)"></td>
        <td width="10"></td>
        <td rowspan="2" valign="top">
          <fieldset id='scTime'>
            <legend data-i18n="settings.schedule.schedule">Timeslot</legend>
            <label for="timerOpOnOff" data-i18n="settings.schedule.onoff">OnOff operation</label>:
            <div class="hintButton" onclick="helpOn('onOffOperationHint')">i</div><br>
            <select id="timerOpOnOff" style="position:relative" onchange="changeScheduleOp(this.value);displaySaveHint();">
              <option value="0" data-i18n="settings.schedule.operations.alwaysOff">UNCONDITIONAL_OFF</option>
              <option value="1" data-i18n="settings.schedule.operations.alwaysOn">UNCONDITIONAL_ON</option>
              <option value="3" data-i18n="settings.schedule.operations.controlledOn">CONTROLLED_ON</option>
              <option value="5" data-i18n="settings.schedule.operations.controlledOnCheapest">CONTROLLED_CHEAPEST</option>
              <option value="2" data-i18n="settings.schedule.operations.controlledOff">CONTROLLED_OFF</option>
              <option value="4" data-i18n="settings.schedule.operations.ignore">IGNORE</option>
            </select><br>
            <div id="maxHoursContainer">
              <label for="maxHours" data-i18n="settings.schedule.maxHours">Max Hours</label>:<br>
              <input id="maxHours" class="inputElem" type="number" min="1" max="24" step="1" onchange="changeMaxHours(this.value);displaySaveHint()">
              <span data-i18n="units.hours">h</span>
            </div>
            <label for="timerOpTemp" data-i18n="settings.schedule.temp">Temperature</label>:
            <div class="hintButton" onclick="helpOn('tempOpHint')">i</div><br>
            <select id="timerOpTemp" style="position:relative;" onchange="changeTempOp(this.value);displaySaveHint();">
                <option value="0" data-i18n="settings.schedule.notemp">No temp control</option>
                <option value="1" data-i18n="settings.schedule.statictemp">Static temperature</option>
                <option value="2" data-i18n="settings.schedule.pricetemp">Price controlled</option>
            </select><br>
            <label for="timerACMode" data-i18n="settings.ACMode.header">AC Mode</label>:
            <div class="hintButton" onclick="helpOn('ACModeHint')">i</div><br>
            <select id="timerACMode" style="position:relative;" onchange="changeACMode(this.value);displaySaveHint();">
              <option value="6" data-i18n="settings.ACMode.piggy">Piggy</option>
              <option value="0" data-i18n="settings.ACMode.fromAC">Unchanged</option>
              <option value="1" data-i18n="settings.ACMode.auto">Auto</option>
              <option value="2" data-i18n="settings.ACMode.heat" id="heatText">Heating</option>
              <option value="3" data-i18n="settings.ACMode.cool" id="coolText">Cooling</option>
              <option value="4" data-i18n="settings.ACMode.dry">Dry</option>
              <option value="5" data-i18n="settings.ACMode.fan">Fan</option>
            </select><br>
            <div id="thermoTab" class="maxWidth">
              <canvas id="myThermostat" class="thermo" width="400" height="400" onpointermove="draggingThermo(this, event);" onpointerdown="startDragThermo(this, event);" onpointerup="stopDragThermo(this, event);" onpointerleave="stopDragThermo(this, event);">
                Your browser does not support the HTML5 canvas tag.
              </canvas>
              <div class="hintButton" style="position: absolute; top: 5px; left: 5px;" onclick="helpOn('myThermoHint')">i</div>
              <div id="closeThermo" class="closeButton" style="position: absolute; top: 5px; right: 5px; min-width: 20px;" onclick="if (thermoIsBig) unZoomThermo(); else zoomThermo()">&#8703;</div>
              <p id="thermoGuide" class="centerText"></p>
            </div>
            <div id="noneSelected" style="color:red; font-weight: bold;" data-i18n="settings.schedule.noneSelected">&larr; Please select an interval to edit.</div>
          </fieldset>
          <div hidden>
            <div id="scTemp">
              <label for="timerBaseTempHeat" data-i18n="settings.schedule.basetemp">Base temperature (heating)</label>:<br>
              <input id="timerBaseTempHeat" class="inputElem" type="number" min="-30" max="90" step="0.5" onchange="changeBaseTemp(this.value);displaySaveHint()">°C<br>
              <div id="coolBase">
                <label for="timerBaseTempCool" data-i18n="settings.schedule.basetemp">Base temperature (cooling)</label>:<br>
                <input id="timerBaseTempCool" class="inputElem" type="number" min="-30" max="90" step="0.5" onchange="changeBaseTemp(this.value);displaySaveHint()">°C<br>
              </div>
            </div>
            <fieldset id='scPP'>
            <legend data-i18n="settings.menu.devices.prices">Price adjust</legend>
            <label for="tempDirtCheap" data-i18n="settings.pricetab.dirtcheap">Dirt Cheap</label>:<br>
            <input id="tempDirtCheap" class="inputElem" type="number" min="-30" max="90" step="0.5" onchange="changeDeltaTemp(0, this.value);displaySaveHint()">°C<br>
            <label for="tempCheap" data-i18n="settings.pricetab.cheap">Cheap</label>:<br>
            <input id="tempCheap" class="inputElem" type="number" min="-30" max="90" step="0.5" onchange="changeDeltaTemp(1, this.value);displaySaveHint()">°C<br>
            <label for="tempExpensive" data-i18n="settings.pricetab.expensive">Expensive</label>:<br>
            <input id="tempExpensive" class="inputElem" type="number" min="-30" max="90" step="0.5" onchange="changeDeltaTemp(3, this.value);displaySaveHint()">°C<br>
            <label for="tempExtreme" data-i18n="settings.pricetab.extreme">Extreme</label>:<br>
            <input id="tempExtreme" class="inputElem" type="number" min="-30" max="90" step="0.5" onchange="changeDeltaTemp(4, this.value);displaySaveHint()">°C<br>
          </fieldset>
          </div>
        </td>
      </tr>
      <tr><td colspan="2"></td><td style="vertical-align:top;"><input id="addTimer" style="width:100%; position: relative;" type="button" value="+" onclick="addTimer();"></td></tr>
    </table>

  <script type="text/javascript">
    window.addEventListener("message", (event) => {
      if ((event.origin !== window.location.origin) &&
        (event.origin !== 'null')) {
        console.log(`Didn't work! (origin: ${event.origin})`);
        return;
      }
      const decoded = JSON.parse(event.data);
      if (decoded.id === 'Initialize') {
        console.log(`Initializing time schedule`);
        wizContainer = event.source;
        parent = decoded.data;
        selectSchedule(0);
        refreshSchedules();
        refreshThermostat();
        helpOn('previewHint');
      } else if (decoded.id === 'translations') {
        console.log(`Translating time schedule`);
        updateTranslations(decoded);
      } else if (decoded.id === 'resize') {
        const data = {
          id: 'resize',
          w: document.documentElement.scrollWidth,
          h: document.documentElement.scrollHeight
        }
        event.source.postMessage(JSON.stringify(data), '*');
      }
    });
    const startTemp = 5;
    const endTemp = 45;
    let temps = [5, 15, 20, 21, 22, 23, 24, 25, 26, 27, 30, 45];

    const tempsID = {
      HEAT_OFF:       0,
      HEAT_EXPENSIVE: 1,
      HEAT_HIGH:      2,
      HEAT_NORMAL:    3,
      HEAT_CHEAP:     4,
      HEAT_DIRTCHEAP: 5,
      COOL_DIRTCHEAP: 6,
      COOL_CHEAP:     7,
      COOL_NORMAL:    8,
      COOL_HIGH:      9,
      COOL_EXPENSIVE: 10,
      COOL_OFF:       11,
    }
    const tempName = {
      0: 'HeatOff',
      1: 'HeatExtreme',
      2: 'HeatExpensive',
      3: 'HeatNormal',
      4: 'HeatCheap',
      5: 'HeatDirtCheap',
      6: 'CoolDirtCheap',
      7: 'CoolCheap',
      8: 'CoolNormal',
      9: 'CoolExpensive',
      10: 'CoolExtreme',
      11: 'CoolOff',
    }
    const TEMPOP = {
      NONE: 0,
      STATIC: 1,
      PRICE: 2
    }
    const totalHeight = 24*16;
    const pixelsPerMinute = (totalHeight) / (24 * 60);
    let minuteSnap = 30;
    let scheduleMin = 1;
    let scheduleMax = 8;
    let scheduleSelected = 0;
    let timerSelected = undefined;
    var dragging = false;
    let aboveIdx;
    let belowIdx;
    let prevPosY;
    let aboveItem;
    let belowItem;

    function changeTempOp(newTempOp) {
      if (!(scheduleSelected in parent.schedules) || (timerSelected == undefined)) {
        return;
      }
      const curSchedule = parent.schedules[scheduleSelected];
      const items = curSchedule.items;
      items[timerSelected].tempOp = +newTempOp;
      // Refresh
      refreshTempOp();
      refreshTimeTable();
      refreshThermostat();
    }

    function changeACMode(newMode) {
      if (timerSelected === undefined) return;
      parent.schedules[scheduleSelected].items[timerSelected].ACMode = +newMode;
      if (+newMode === ACMODE.DRY || +newMode === ACMODE.FAN) {
        document.getElementById('timerOpTemp').value = TEMPOP.NONE;
        //newMode === ACMODE.UNCHANGED;
      }
      if (+newMode === ACMODE.AUTO) {
        document.getElementById('timerOpTemp').value = TEMPOP.STATIC;
        //newMode === ACMODE.UNCHANGED;
      }
      showHeat = ((+newMode === ACMODE.PIGGY) || (+newMode === ACMODE.HEAT) || (+newMode === ACMODE.UNCHANGED)  || (+newMode === ACMODE.AUTO))
      showCool = ((+newMode === ACMODE.PIGGY) || (+newMode === ACMODE.COOL) || (+newMode === ACMODE.UNCHANGED))
      document.getElementById('coolBase').style.display = showCool ? 'block' : 'none';
      refreshTempOp();
      refreshTimeTable();
      refreshThermostat();
    }

    function changeBaseTemp(newTemp) {
      parent.schedules[scheduleSelected].items[timerSelected].temp = +newTemp;
      refreshTimeTable();
    }

    function refreshTempOp() {
      const tempElement = document.getElementById('scTemp');
      const ppElements = document.getElementById('scPP');
      const tempOp = +document.getElementById('timerOpTemp').value;
      const timerACMode = +document.getElementById('timerACMode').value;
      const thermoTab = document.getElementById('thermoTab');
      if (tempOp === TEMP_OP.NONE
        || timerACMode === ACMODE.DRY
        || timerACMode === ACMODE.FAN) {
        tempElement.style.display = "none";
        ppElements.style.display = "none";
        thermoTab.style.display = "none";
      } else if (tempOp === TEMP_OP.STATIC
        || timerACMode === ACMODE.AUTO) {
        tempElement.style.display = "block";
        ppElements.style.display = "none";
        thermoTab.style.display = "block";
      } else if (tempOp === TEMP_OP.PRICE) {
        tempElement.style.display = "block";
        ppElements.style.display = "block";
        thermoTab.style.display = "block";
      }
      // Change AC options
      document.querySelectorAll("#timerACMode option").forEach(opt => {
        if (((tempOp === TEMPOP.NONE)
          && ((+(opt.value) !== ACMODE.FAN)
            && (+(opt.value) !== ACMODE.DRY)
            && (+(opt.value) !== ACMODE.UNCHANGED)))
          || ((tempOp === TEMPOP.PRICE)
            && (+opt.value === ACMODE.AUTO
              || +opt.value === ACMODE.DRY
              || +opt.value === ACMODE.FAN))
          || ((tempOp === TEMPOP.STATIC)
            && (+opt.value === ACMODE.DRY
             || +opt.value === ACMODE.FAN))) {
          opt.disabled = true;
        } else {
          opt.disabled = false;
        }
      });
    }

    function selectSchedule(value) {
      scheduleSelected = value;
      timerSelected = undefined;
      const nameElement = document.getElementById('timerOpName');
      const ppDirtElement = document.getElementById('tempDirtCheap');
      const ppCheapElement = document.getElementById('tempCheap');
      const ppExpensiveElement = document.getElementById('tempExpensive');
      const ppExtremeElement = document.getElementById('tempExtreme');
      if (value in parent.schedules) {
        nameElement.disabled = false;
        nameElement.value = parent.schedules[value].name;
      } else {
        nameElement.disabled = true;
        nameElement.value = '';
      }
      selectTimer(undefined);
      refreshTimeTable();
    }

    function addSchedule() {
      let newSchedule = {
        name: 'New Schedule',
        deltaTemp: 1,
        items: [{
          start: 0,
          operation: DEVICE_OP.CONTROLLED_ON,
          tempOp: TEMP_OP.PRICE,
          temp: [5, 20, 21, 23, 25, 26, 27, 28, 29, 30, 31, 45],
          ACMode: 0,
          maxHours: 4
        }]
      };
      parent.schedules.push(newSchedule);
      selectSchedule(parent.schedules.length - 1);
      refreshSchedules();
    }

    function removeSchedule() {
      if ((scheduleSelected == '')
        || (+scheduleSelected > (parent.schedules.length-1))
        || (parent.schedules.length === 1)) {
        return;
      }
      if (timerSelected !== undefined) selectTimer(timerSelected); // Deselect timer if selected
      parent.schedules.splice(scheduleSelected,1);
      selectSchedule('');
      refreshSchedules();
      document.getElementById('allSchedules').value='';
    }

    function refreshSchedules(change) {
      let allSchedulesElement = document.getElementById('allSchedules');
      let newList = '';
      for (let i = 0; i < parent.schedules.length; i++) {
        const selectText = (i === scheduleSelected) ? ' selected' : '';
        newList += `<option value="${i}"${selectText}>${parent.schedules[i].name}</option>"`;
      }
      allSchedulesElement.innerHTML = newList;
      refreshTimeTable();
    }

    function timerHeight(item) {
      const items = parent.schedules[scheduleSelected].items;
      const abovePos = items[item].start;
      const belowPos = ((item + 1) >= items.length) ? (24 * 60) : items[item + 1].start;
      const height = (belowPos - abovePos) * pixelsPerMinute;
      return height;
    }

    function addTimer() {
      if (!(scheduleSelected in parent.schedules)) {
        return;
      }
      const curSchedule = parent.schedules[scheduleSelected];
      const items = curSchedule.items;
      const numTimers = items.length;
      console.log(`len: ${numTimers}`);
      if (numTimers < scheduleMax) {
        items[numTimers] = {
          ...items[numTimers-1],
          temp: [...items[numTimers -1].temp],
          start: (items[numTimers - 1].start + 24 * 60) / 2
        }
        let lastStart = 24 * 60;
        for (let i = numTimers; i > 0; i--) {
          if (lastStart - items[i].start < 60) {
            items[i].start = lastStart - 60;
          }
          lastStart = items[i].start;
        }
      }
      displaySaveHint();
      refreshTimeTable();
    }

    function removeTimer(idx) {
      if (!(scheduleSelected in parent.schedules)) {
        return;
      }
      if (timerSelected !== undefined) selectTimer(timerSelected); // Deselect timer if selected
      const items = parent.schedules[scheduleSelected].items;
      const numTimers = items.length;
      if (numTimers > scheduleMin) {
        items.splice(idx, 1);
        items[0].start = 0;
      }
      displaySaveHint();
      refreshTimeTable();
    }

    function getTimeBlockText(idx) {
      const curSchedule = parent.schedules[scheduleSelected]
      const items = curSchedule.items;
      const startTime = items[idx].start;
      const endTime = ((idx + 1) >= items.length) ? (24 * 60) : items[idx+1].start;
      const hourStart = String(Math.floor(startTime / 60)).padStart(2, '0');
      const minStart = String(startTime % 60).padStart(2, '0');
      const hourEnd = String(Math.floor(endTime / 60)).padStart(2, '0');
      const minEnd = String(endTime % 60).padStart(2, '0');
      const tempOp = items[idx].tempOp;
      const trashCan = (items.length === 1) ? '' :
        `<div id="scTrashCan" class="icon-trash" style="float:right; font-size:1rem" onClick="removeTimer(${idx});event.stopPropagation();displaySaveHint();">`
        + '  <div class="trash-lid" style="background-color: #e44"></div>'
        + '  <div class="trash-container" style="background-color: #e44"></div>'
        + '  <div class="trash-line-1"></div>'
        + '  <div class="trash-line-2"></div>'
        + '  <div class="trash-line-3"></div>'
        + '</div>';
      const tempMin = items[idx].temp[tempsID.HEAT_EXPENSIVE];
      const tempMax = items[idx].temp[tempsID.COOL_EXPENSIVE];
      const tempText = (tempOp == TEMP_OP.NONE) ? ''
        : (tempOp == TEMP_OP.STATIC) ? `${tempMin}°C<br>`
          : `${tempMin}°C - ${tempMax}°C<br>`;
      const blockText = `${trashCan}${tempText}${hourStart}:${minStart} - ${hourEnd}:${minEnd}`;
      return blockText;
    }

    function changeScheduleOp(value) {
      if (scheduleSelected in parent.schedules && timerSelected !== undefined) {
        const curSchedule = parent.schedules[scheduleSelected];
        const items = curSchedule.items
        const oldOp = items[timerSelected].operation;
        items[timerSelected].operation = value;
        const timerElement = document.getElementById(`si${timerSelected}`);
        timerElement.classList.remove(`schedCol${oldOp}`);
        timerElement.classList.add(`schedCol${value}`);
        displaySaveHint();
        refreshScheduleOp();
        refreshThermostat();
      }
    }

    function changeMaxHours(value) {
      if (scheduleSelected in parent.schedules && timerSelected !== undefined) {
        const curSchedule = parent.schedules[scheduleSelected];
        const items = curSchedule.items;
        items[timerSelected].maxHours = value;
      }
    }

    function refreshScheduleOp() {
      const { value } = document.getElementById('timerOpOnOff');
      const maxHours = document.getElementById('maxHoursContainer');
      if (+value === DEVICE_OP.CONTROLLED_CHEAPEST) {
        maxHours.style.display = 'block';
      } else {
        maxHours.style.display = 'none';
      }
    }

    function refreshTimeTable(change) {
      const container = document.getElementById("scheduleContainer");
      const currentSchedule = parent.schedules[scheduleSelected];
      const numTimers = (scheduleSelected in parent.schedules) ? currentSchedule.items.length : 0;
      let newContent = '<div style="position:relative;">';
      newContent += `<div style="height:${pixelsPerMinute*30}px"></div>`;
      let yPos = pixelsPerMinute*30;
      for (let i = 0; i < numTimers; i++) {
        if (i > 0) {
          newContent += `<div id="s${i-1}" class="scheduleSpacer" onpointerdown="dragStart(event, this)" style="top:${yPos-10}px"></div>`;
        }
        const blockText = getTimeBlockText(i);
        const cc = +currentSchedule.items[i].operation;
        const thisHeight = timerHeight(i);
        yPos += thisHeight;
        newContent += `<div id="si${i}" class="scheduleItem schedCol${cc} ${timerSelected===i ? ' scheduleSelect' : ''}" onclick="selectTimer(${i})" style="height:${thisHeight}px">${blockText}</div>`;
      }
      newContent += "</div>";
      container.innerHTML = newContent;
      try {
        refreshThermostat();
      } catch (err) {
        // Don't refresh thermostat when it's not visible
      }
    }

    function selectTimer(sourceId) {
      const sourceElement = document.getElementById(`si${sourceId}`);
      const onoffElement = document.getElementById('timerOpOnOff');
      //const tempElement = document.getElementById('timerBaseTempHeat');
      const ACModeElement = document.getElementById('timerACMode');
      const timeElements = document.getElementById('scTime');
      const ppElements = document.getElementById('scPP');
      //const ppDirtElement = document.getElementById('tempDirtCheap');
      //const ppCheapElement = document.getElementById('tempCheap');
      //const ppExpensiveElement = document.getElementById('tempExpensive');
      //const ppExtremeElement = document.getElementById('tempExtreme');
      const tempOpElement = document.getElementById('timerOpTemp');
      const maxHoursElement = document.getElementById('maxHours');
      if (timerSelected !== undefined) {
        const oldElement = document.getElementById(`si${timerSelected}`);
        oldElement.classList.remove('scheduleSelect');
      }
      timeElements.disabled = true;
      onoffElement.disabled = true;
      ppElements.disabled = true;
      //ppDirtElement.value = '';
      //ppCheapElement.value = '';
      //ppExpensiveElement.value = '';
      //ppExtremeElement.value = '';

      let newOnOffOp = '';
      let newTemp = '';
      let ACMode = 0;
      if (timerSelected === sourceId) {
        document.getElementById("noneSelected").style.display = 'block';
        timerSelected = undefined;
        tempOpElement.value = TEMPOP.NONE;
      } else {
        document.getElementById("noneSelected").style.display = 'none';
        timerSelected = sourceId;
        sourceElement.classList.add('scheduleSelect');
        timeElements.disabled = false;
        onoffElement.disabled = false;
        const currentSchedule = parent.schedules[scheduleSelected];
        newOnOffOp = currentSchedule.items[timerSelected].operation;
        //newTemp = currentSchedule.items[timerSelected].temp;
        ACMode = currentSchedule.items[timerSelected].ACMode;
        ppElements.disabled = false;
        temps = currentSchedule.items[timerSelected].temp;
        //ppDirtElement.value = currentSchedule.items[timerSelected].deltas[0];
        //ppCheapElement.value = currentSchedule.items[timerSelected].deltas[1];
        //ppExpensiveElement.value = currentSchedule.items[timerSelected].deltas[3];
        //ppExtremeElement.value = currentSchedule.items[timerSelected].deltas[4];
        tempOpElement.value = currentSchedule.items[timerSelected].tempOp;
        maxHoursElement.value = (currentSchedule.items[timerSelected].maxHours);
      }
      onoffElement.value = newOnOffOp;
      refreshScheduleOp();
      refreshTempOp();
      refreshThermostat();
      //tempElement.value = newTemp;
      ACModeElement.value = ACMode;
      changeACMode(ACMode);
    }

    function dragStart(e, source) {
      dragging = true;
      aboveItem = source.previousElementSibling;
      belowItem = source.nextElementSibling;
      aboveIdx = +source.id.slice(1);
      belowIdx = aboveIdx + 1;
      prevPosY = event.clientY;
    }

    function moving(e) {
      if (dragging) {
        const items = parent.schedules[scheduleSelected].items;
        let deltaY = e.clientY - prevPosY;
        let deltaMinutes = Math.round(deltaY / (pixelsPerMinute * minuteSnap)) * minuteSnap;
        if (Math.abs(deltaMinutes) >= minuteSnap) {
          const minSize = 60;
          const minAbove = items[belowIdx].start - items[aboveIdx].start;
          const minBelow = (((belowIdx+1)>=items.length) ? (24*60) :items[belowIdx+1].start) - items[belowIdx].start;
          if (minBelow - deltaMinutes < minSize) deltaMinutes = minBelow - minSize;
          if (minAbove + deltaMinutes < minSize) deltaMinutes = minSize - minAbove;
          items[belowIdx].start += deltaMinutes;

          aboveItem.style.height = `${timerHeight(aboveIdx)}px`;
          belowItem.style.height = `${timerHeight(belowIdx)}px`;
          const prevY = +document.getElementById(`s${aboveIdx}`).style.top.slice(0,-2);
          const spacer = document.getElementById(`s${aboveIdx}`);
          spacer.style.top = `${prevY + deltaMinutes * pixelsPerMinute}px`;
          spacer.value = `${Math.floor(items[belowIdx].start/60)}:${String(items[belowIdx].start%60).padStart(2, '0')}`;
          if (spacer.onchange) spacer.onchange(spacer.value);

          prevPosY = (deltaMinutes * pixelsPerMinute) + prevPosY;
        }
        document.getElementById(`si${aboveIdx}`).innerHTML = getTimeBlockText(aboveIdx);
        document.getElementById(`si${belowIdx}`).innerHTML = getTimeBlockText(belowIdx);
      }
    }

    function dragStop(e) {
      dragging = false;
      displaySaveHint();
    }

    function changeDeviceAction(button, newstate) {
      switch (+newstate) {
        case DEVICE_OP.UNCONDITIONAL_OFF:
          button.style.backgroundImage = 'radial-gradient(white, lightgray, gray)';
          break;
        case DEVICE_OP.UNCONDITIONAL_ON:
          button.style.backgroundImage = 'radial-gradient(white, rgb(255, 255, 150), orange)';
          break;
          case DEVICE_OP.CONTROLLED_OFF:
          button.style.backgroundImage = 'radial-gradient(white, rgb(150, 255, 150), green)';
          break;
        case DEVICE_OP.CONTROLLED_ON:
          button.style.backgroundImage = 'radial-gradient(white, rgb(150, 255, 150), green)';
          break;
        case DEVICE_OP.IGNORE:
          button.style.backgroundImage = 'radial-gradient(white, lightgray, gray)';
          break;
      }
    }

    function displaySaveHint() {
      if (wizContainer) {
        wizContainer.postMessage(JSON.stringify({id: 'displaySaveHint'}), '*');
        console.log('TODO: Post back schedule for saving');
      } else {
        console.log('ERROR: iFrame has not been connected properly.');
      }
    }

    // ===== THERMOSTAT CODE =====
    var thermoIsDragging = false;
    var thermoDragIndex;
    // Dimensions
    let cWidth = 1;
    let cHeight = 1;
    let tCenterX = 0;
    let tCenterY = 0;
    let outerDia = 1;
    let innerDia = 0;
    // Positions
    const markerStartPos = Math.PI * 8 / 10;
    const markerEndPos = Math.PI * 22 / 10;
    // Temp ranges
    let showHeat = true;
    let showCool = true;
    let thermoIsBig = false;
    let scaleFactor = 400/180;

    function pressToAngleCoords(canvas, event) {
      let rect = canvas.getBoundingClientRect();
      let pos = {x: event.clientX - rect.left, y: event.clientY - rect.top };

      const innerScale = 400 / rect.width;

      let w = pos.x - (tCenterX/innerScale);
      let h = pos.y - (tCenterX/innerScale);
      let pressRadius = Math.sqrt(w * w + h * h) * innerScale;
      let pressAngle = Math.atan2(h, w);
      if (pressAngle < 0) pressAngle += 2*Math.PI;
      if (pressAngle < Math.PI/2) pressAngle += 2*Math.PI;
      let pressTemp = tempToAngle(startTemp, endTemp, markerStartPos, markerEndPos, pressAngle);
      return { pressRadius, pressAngle, pressTemp };
    }

    function startDragThermo(canvas, event) {
      const { pressRadius, pressAngle, pressTemp } = pressToAngleCoords(canvas, event);
      if (pressRadius > innerDia * 0.8 && pressRadius < outerDia * 1.2) {
        let closestIndex;
        let closestDist = Infinity;
        for (let t = 0; t < temps.length; t++) {
          if (t >= tempsID.HEAT_OFF && t <= tempsID.HEAT_DIRTCHEAP && !showHeat) continue;
          if (t >= tempsID.COOL_DIRTCHEAP && t <= tempsID.COOL_OFF && !showCool) continue;
          let closeness = Math.abs(pressTemp - temps[t]);
          if ((closeness < closestDist)
            || (closeness === closestDist && (pressTemp > temps[t]))) {
            closestDist = closeness;
            closestIndex = t;
          }
        }
        // minTemp
        if (pressAngle > markerStartPos - Math.PI/10 && pressAngle < markerStartPos + Math.PI/40) {
          console.log('Change min temp')
        }
        // maxTemp
        if (pressAngle > markerEndPos - Math.PI/40 && pressAngle < markerEndPos + Math.PI/10) {
          console.log('Change max temp')
        }
        // Drag Temp
        thermoIsDragging = true;
        thermoDragIndex = closestIndex;
        const timerOpTemp = +document.getElementById('timerOpTemp').value;
        if (timerOpTemp === TEMPOP.STATIC) {
          if (thermoDragIndex >= tempsID.HEAT_EXPENSIVE && thermoDragIndex <= tempsID.HEAT_DIRTCHEAP) thermoDragIndex = tempsID.HEAT_NORMAL;
          if (thermoDragIndex <= tempsID.COOL_EXPENSIVE && thermoDragIndex >= tempsID.COOL_DIRTCHEAP) thermoDragIndex = tempsID.COOL_NORMAL;
        }
        draggingThermo(canvas, event);
        return;
      } else if (thermoIsBig) {
        unZoomThermo();
      } else if (pressRadius < innerDia * 0.8) {
        zoomThermo();
      }
    }

    function zoomThermo() {
      myThermostat = document.getElementById("thermoTab");
      thermoIsBig = true;
      myThermostat.style.zIndex = 30; // This is the same as wizzard focus
      myThermostat.style.position="absolute";
      myThermostat.style.top = "50%";
      myThermostat.style.left = "50%";
      myThermostat.style.transform = "translate(-50%, -50%)";
      myThermostat.style.backgroundColor = "rgba(0,0,0,0.7)";
      document.getElementById("closeThermo").innerHTML = "X";
      document.getElementById("thermoGuide").style.color = "white";
    }

    function unZoomThermo() {
      myThermostat = document.getElementById("thermoTab");
      thermoIsBig = false;
      myThermostat.style.position="relative";
      myThermostat.style.zIndex = "";
      myThermostat.style.top = "";
      myThermostat.style.left = "";
      myThermostat.style.marginLeft = "";
      myThermostat.style.marginRight = "";
      myThermostat.style.transform = "";
      myThermostat.style.backgroundColor = "rgba(0,0,0,0.0)";
      document.getElementById("closeThermo").innerHTML = "&#8703;";
      document.getElementById("thermoGuide").style.color = "black";
    }

    function setThermoValue(index, newTemp) {
      parent.schedules[scheduleSelected].items[timerSelected].temp[index] = Math.round(newTemp*2)/2;
      temps[index] = newTemp;

      refreshTimeTable();
    }

    function moveThermoIndex(index, newTemp) {
      // Scale Pricepoints if applicable
      const timerOpTemp = +document.getElementById('timerOpTemp').value;
      if (timerOpTemp === TEMPOP.PRICE) {
        if (index === tempsID.HEAT_DIRTCHEAP
          || index === tempsID.HEAT_EXPENSIVE
          || index === tempsID.COOL_DIRTCHEAP
          || index === tempsID.COOL_EXPENSIVE) {
          const oldStart = temps[(index < tempsID.COOL_DIRTCHEAP) ? tempsID.HEAT_EXPENSIVE : tempsID.COOL_DIRTCHEAP];
          const oldEnd = temps[(index < tempsID.COOL_DIRTCHEAP) ? tempsID.HEAT_DIRTCHEAP : tempsID.COOL_EXPENSIVE];
          const newStart = (index === tempsID.HEAT_EXPENSIVE || index === tempsID.COOL_DIRTCHEAP) ? newTemp : oldStart;
          const newEnd = (index === tempsID.HEAT_DIRTCHEAP || index === tempsID.COOL_EXPENSIVE) ? newTemp : oldEnd;
          const iStart = (index < tempsID.COOL_DIRTCHEAP) ? tempsID.HEAT_HIGH : tempsID.COOL_CHEAP;
          const iEnd = (index < tempsID.COOL_DIRTCHEAP) ? tempsID.HEAT_DIRTCHEAP : tempsID.COOL_EXPENSIVE;
          for (let i = iStart; i < iEnd; i++) {
            setThermoValue(i, newStart + ((oldEnd === oldStart)
              ? ((i-iStart+1) / 4 * (newEnd-newStart))
                : (((temps[i]-oldStart)/(oldEnd-oldStart)) * (newEnd-newStart)))
            );
          }
        }
      }
      // Set new temperature
      setThermoValue(index, newTemp);
    }

    function draggingThermo(canvas, event) {
      if (thermoIsDragging) {
        const { pressTemp } = pressToAngleCoords(canvas, event);
        let newTemp = Math.round(pressTemp*2) / 2;
        if (newTemp < startTemp) newTemp = startTemp;
        if (newTemp > endTemp) newTemp = endTemp;
        if (newTemp > 15 && thermoDragIndex === tempsID.HEAT_OFF) newTemp = 15;
        const timerOpTemp = +document.getElementById('timerOpTemp').value;
        moveThermoIndex(thermoDragIndex, newTemp);
        // Fix up the rest of the values:
        if (timerOpTemp === TEMPOP.STATIC) {
          for (let i = tempsID.HEAT_EXPENSIVE; i <= tempsID.HEAT_DIRTCHEAP; i++) {
            setThermoValue(i, temps[tempsID.HEAT_NORMAL]);
          }
          for (let i = tempsID.COOL_DIRTCHEAP; i <= tempsID.COOL_EXPENSIVE; i++) {
            setThermoValue(i, temps[tempsID.COOL_NORMAL]);
          }
        }
        // Push other values out of the new range
        for (let i = thermoDragIndex - 1; i >= 0; i--) {
          if (temps[i] > newTemp) moveThermoIndex(i, newTemp);
        }
        for (let i = thermoDragIndex + 1; i < temps.length; i++) {
          if (temps[i] < newTemp) moveThermoIndex(i, newTemp);
        }
        refreshThermostat();
      }
    }

    function stopDragThermo(canvas, event) {
      if (thermoIsDragging) {
        draggingThermo(canvas, event);
        thermoIsDragging = false;
      }
    }

    function centerText(ctx, text, x, y, fill = false) {
      const textWidth = ctx.measureText(text).width;
      if (fill) {
        ctx.fillText(text, x - (textWidth/2), y);
      } else {
        ctx.strokeText(text, x - (textWidth/2), y);
      }
    }

    function arcText(ctx, text, x, y, distance, angle) {
      const textWidth = ctx.measureText(text).width;
      const arcX = x + Math.cos(angle) * distance;
      const arcY = y + Math.sin(angle) * distance;
      ctx.fillText(text, arcX - (textWidth/2), arcY);
    }

    function tempToAngle(startAngle, endAngle, startTemp, endTemp, temp) {
      return startAngle + ((endAngle - startAngle) * (temp - startTemp) / (endTemp - startTemp));
    }

    function drawArc(ctx, col, arcStart, arcEnd, radius, width) {
      ctx.beginPath();
      ctx.lineWidth = width;
      const angleStart = tempToAngle(markerStartPos, markerEndPos, startTemp, endTemp, arcStart - 0.25);
      const angleEnd = tempToAngle(markerStartPos, markerEndPos, startTemp, endTemp, arcEnd + 0.25);
      if (Array.isArray(col)) {
        let gr = ctx.createConicGradient(angleStart+(Math.PI/2),tCenterX, tCenterY); 
        let colStop = ((angleEnd-angleStart)/(Math.PI*2))%1;
        if (colStop < 0) return;
        gr.addColorStop(0,col[0]);
        gr.addColorStop(colStop,col[1]); 
        ctx.strokeStyle = gr;
      } else {
        ctx.strokeStyle = col;
      }
      ctx.arc(tCenterX, tCenterY, radius, angleStart, angleEnd);
      ctx.stroke();
    }

    function refreshThermostat(ttt = undefined) {
      if (timerSelected === undefined) return;
      try {
        const canvas = document.getElementById("myThermostat");
        const ctx = canvas.getContext("2d");
        // OnOff temp?
        const curSchedule = parent.schedules[scheduleSelected];
        const items = curSchedule.items;
        const onOffOp = items[timerSelected].operation;
        const tempOp = +document.getElementById('timerOpTemp').value;
        const ACMode = +document.getElementById('timerACMode').value;
        let showTempOnOff =
          (tempOp === TEMPOP.NONE
          || ACMode === ACMODE.AUTO
          || ACMode === ACMODE.DRY
          || ACMode === ACMODE.FAN)
          ? false : true;
        let mustUseTemp =
          onOffOp === DEVICE_OP.IGNORE
          || onOffOp === DEVICE_OP.UNCONDITIONAL_ON; // (None for on/off)
          //onOffOp === DEVICE_OP.CONTROLLED_ON    => Temp (onoff else)

        // Dimensions
        cWidth = canvas.width;
        cHeight = canvas.height;
        tCenterX = (cWidth / 2);
        tCenterY = (cHeight / 2);
        outerDia = Math.min(tCenterX, tCenterY)-(10*scaleFactor);
        innerDia = outerDia * 3 / 4;
        // Outer circle
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.arc(tCenterX, tCenterY, outerDia, 0, 2 * Math.PI);
        ctx.fillStyle = "#DDD";
        ctx.strokeStyle = "#000";
        ctx.fill();
        ctx.stroke();
        // Inner circle
        ctx.beginPath();
        ctx.arc(tCenterX, tCenterY, innerDia, 0, 2 * Math.PI);
        ctx.fillStyle = "#CCC";
        ctx.fill();
        ctx.stroke();
        // Markers
        const numMarkers = endTemp - startTemp;
        for (let i = 0; i <= numMarkers; i++) {
          const markerPos = markerStartPos + i * (markerEndPos - markerStartPos) / numMarkers;
          const markerTemp = startTemp + i;
          ctx.lineWidth = (3 + 2*(markerTemp%5==0) + 3*(markerTemp%10==0))*scaleFactor;
          ctx.beginPath();
          ctx.arc(tCenterX, tCenterY, (2*outerDia - ctx.lineWidth) / 2, markerPos, markerPos + 0.01);
          ctx.stroke();
        }
        // Show temp ranges
        const timerOpTemp = +document.getElementById('timerOpTemp').value;
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = "#000";
        ctx.font = `${Math.round(8*scaleFactor*10)/10}px Verdana`;
        ctx.fillStyle = "#000";
        arcText(ctx, `${startTemp}°C`, tCenterX, tCenterY, (outerDia+innerDia+4)/2, markerStartPos-(Math.PI/20));
        arcText(ctx, `${endTemp}°C`, tCenterX, tCenterY, (outerDia+innerDia+4)/2, markerEndPos+(Math.PI/20));
        ctx.fill();

        let value = [];
        if (showHeat) {
          value.push(temps[tempsID.HEAT_OFF]);
          // Mode specific
          let rangeStart, rangeEnd;
          if (timerOpTemp === TEMPOP.PRICE) {
            rangeStart = temps[tempsID.HEAT_EXPENSIVE];
            rangeEnd = temps[tempsID.HEAT_DIRTCHEAP];
          } else {
            rangeStart = temps[tempsID.HEAT_NORMAL];
            rangeEnd = temps[tempsID.HEAT_NORMAL];
          }
          const text = (rangeStart === rangeEnd) ? `${Math.round(rangeStart*2)/2}` : `>[${Math.round(rangeStart*2)/2},${Math.round(rangeEnd*2)/2}]`;
          // Heat Arc
          drawArc(ctx, "#F00", rangeStart, rangeEnd, outerDia - 4*scaleFactor, 8*scaleFactor);
          // Heat price points
          if (timerOpTemp === TEMPOP.PRICE) {
            for (let i = tempsID.HEAT_EXPENSIVE; i <= tempsID.HEAT_DIRTCHEAP; i++) {
              drawArc(ctx, "#000", temps[i], temps[i], innerDia + 10*scaleFactor, 4*scaleFactor);
            }
            drawArc(ctx, "#0F0", temps[tempsID.HEAT_CHEAP], temps[tempsID.HEAT_DIRTCHEAP], innerDia + 4*scaleFactor, 8*scaleFactor);
            drawArc(ctx, "#0A0", temps[tempsID.HEAT_NORMAL], temps[tempsID.HEAT_CHEAP], innerDia + 4*scaleFactor, 8*scaleFactor);
            drawArc(ctx, "#A00", temps[tempsID.HEAT_HIGH], temps[tempsID.HEAT_NORMAL], innerDia + 4*scaleFactor, 8*scaleFactor);
            drawArc(ctx, "#F00", temps[tempsID.HEAT_EXPENSIVE], temps[tempsID.HEAT_HIGH], innerDia + 4*scaleFactor, 8*scaleFactor);
            value.push(temps[tempsID.HEAT_DIRTCHEAP]);
            value.push(temps[tempsID.HEAT_CHEAP]);
            value.push(temps[tempsID.HEAT_NORMAL]);
            value.push(temps[tempsID.HEAT_HIGH]);
          }
          // Heat Stop
          if (showTempOnOff) {
            drawArc(ctx, "#800", temps[tempsID.HEAT_OFF], temps[tempsID.HEAT_OFF], outerDia - 10*scaleFactor, 20*scaleFactor);
          }
          // Middle Text
          ctx.beginPath();
          ctx.lineWidth = 1*scaleFactor;
          ctx.strokeStyle = "#D00";
          ctx.font = `${Math.round(14*scaleFactor*10)/10}px Verdana`;
          ctx.fillStyle = "#000";
          const heatText = document.getElementById("heatText").innerHTML;
          centerText(ctx, heatText, tCenterX, tCenterY - 30*scaleFactor);
          centerText(ctx, `${text}°C`, tCenterX, tCenterY - 10*scaleFactor);
          ctx.fill();
          value.push(temps[tempsID.HEAT_EXPENSIVE]);
        }
        if (showCool) {
          value.push(temps[tempsID.COOL_DIRTCHEAP]);
          // Mode specific
          let rangeStart, rangeEnd;
          if (timerOpTemp === TEMPOP.PRICE) {
            rangeStart = temps[tempsID.COOL_DIRTCHEAP];
            rangeEnd = temps[tempsID.COOL_EXPENSIVE];
          } else {
            rangeStart = temps[tempsID.COOL_NORMAL];
            rangeEnd = temps[tempsID.COOL_NORMAL];
          }
          const text = (rangeStart === rangeEnd) ? `${Math.round(rangeStart*2)/2}` : `<[${Math.round(rangeStart*2)/2},${Math.round(rangeEnd*2)/2}]`
          // Cool Arc
          drawArc(ctx, "#00F", rangeStart, rangeEnd, outerDia - 4*scaleFactor, 8*scaleFactor);
          // Cool price points
          if (timerOpTemp === TEMPOP.PRICE) {
            for (let i = tempsID.COOL_DIRTCHEAP; i <= tempsID.COOL_EXPENSIVE; i++) {
              drawArc(ctx, "#000", temps[i], temps[i], innerDia + 10*scaleFactor, 4*scaleFactor);
            }
            drawArc(ctx, "#0F0", temps[tempsID.COOL_DIRTCHEAP], temps[tempsID.COOL_CHEAP], innerDia + 4*scaleFactor, 8*scaleFactor);
            drawArc(ctx, "#0A0", temps[tempsID.COOL_CHEAP], temps[tempsID.COOL_NORMAL], innerDia + 4*scaleFactor, 8*scaleFactor);
            drawArc(ctx, "#A00", temps[tempsID.COOL_NORMAL], temps[tempsID.COOL_HIGH], innerDia + 4*scaleFactor, 8*scaleFactor);
            drawArc(ctx, "#F00", temps[tempsID.COOL_HIGH], temps[tempsID.COOL_EXPENSIVE], innerDia + 4*scaleFactor, 8*scaleFactor);
            value.push(temps[tempsID.COOL_CHEAP]);
            value.push(temps[tempsID.COOL_NORMAL]);
            value.push(temps[tempsID.COOL_HIGH]);
            value.push(temps[tempsID.COOL_EXPENSIVE]);
          }
          // Cool Stop
          if (showTempOnOff) {
            drawArc(ctx, "#008", temps[tempsID.COOL_OFF], temps[tempsID.COOL_OFF], outerDia - 10*scaleFactor, 20*scaleFactor);
          }
          // Middle Text
          ctx.beginPath();
          ctx.lineWidth = 1*scaleFactor;
          ctx.strokeStyle = "#00D";
          ctx.font = `${Math.round(14*scaleFactor*10)/10}px Verdana`;
          ctx.fillStyle = "#000";
          const coolText = document.getElementById("coolText").innerHTML;
          centerText(ctx, coolText, tCenterX, tCenterY + 30*scaleFactor);
          centerText(ctx, `${text}°C`, tCenterX, tCenterY + 10*scaleFactor);
          ctx.fill();
          value.push(temps[tempsID.COOL_OFF]);
        }
        // Show selected temp:
        const guideText = Number.isFinite(thermoDragIndex) ? `${document.getElementById(`${tempName[thermoDragIndex]}Text`).innerHTML}: ${temps[thermoDragIndex]}°C` : '';
        document.getElementById('thermoGuide').innerHTML = guideText;
        canvas.value = value;
        if (canvas.onchange) {
          canvas.onchange(value);
        }
      } catch (err) {
        console.log(`Err: ${err}`);
      }
    }
    // TODO: REMOVE THE PARENT VARIABLE
    try {
      if (parent.modeList === undefined) {
        // For debug only... this will crash the deployment environment
        console.log(`Debug environment detected for: ${window.location}`);
        parent = {
          turnOffText: 'Always Off',
          turnOnText: 'Always On',
          preferredOnText: 'Preferred On', // Nonexisting
          emergencyOffText: 'Controlled Off',
          ignoreText: 'Ignore',
          schedules: [{
            name: "Debug Room",
            deltaTemp: 1,
            items: [{
              start: 0,
              operation: DEVICE_OP.CONTROLLED_ON,
              tempOp: this.TEMP_OP.PRICE,
              temp: [5, 12, 13, 15, 17, 18, 27, 28, 29, 30, 31, 40],
              ACMode: 0,
              maxHours: 4
            },
            {
              start: 15*60,
              operation: DEVICE_OP.CONTROLLED_ON,
              tempOp: this.TEMP_OP.PRICE,
              temp: [5, 21, 22, 24, 26, 27, 27, 28, 29, 30, 31, 40],
              ACMode: 0,
              maxHours: 4
            }]
          }]
        };
        refreshSchedules();
        refreshThermostat();
      } else {
        // This is ok, as it means we run in a real system
        console.log(`Used as an iframe: ${window.location}`);
      }
    } catch (err) {
      console.log(`Used as an iframe inside athom environment: ${window.location}`)
    }
    // --- End of TODO ---
  </script>
  </body>
</html>
